package main

import (
	"fmt"
	"unsafe"
)

type t1 struct {
	id1 int32 // 4
	id2 int64 // 8
	id3 int32 // 4
}

type t2 struct {
	id1 int32 // 4
	id2 int32 // 4
	id3 int64 // 8
}

func main(){
	a := t1{1, 2, 3}
	b := t2{1, 2, 3}
	fmt.Println(unsafe.Sizeof(a)) // 24
	fmt.Println(unsafe.Sizeof(b)) // 16
	fmt.Println(4%0)
	// 首先来分析t1 的结构体 占空间大小, 1表示1byte
	// 11110000 11111111 1111 因为要内存对齐, 保证起始位置和结束位置+1
	// 首先是 4 bytes 的 int32 起始位置0, 结束位置+1=4, 0%4=4%4=0 可以放入;
	// 8bytes的int64, 起始位置为4, 结束位置为 +1 = 12, 4%8 = 0, 但是12%8 = 4, 不可以放入;
	// 直到对齐到起始位置为8, 结束位置 +1 为16 才可以放入, 8%8=16%8 = 0;
	// 最后是4byte的int32, 起始位置为16, 结束位置+1为20  16%4=20%4=0;
	// 一共占用24字节, 在判断结构体是否需要对齐  24 % max(4, 4, 8) = 0

	// 再看t2 结构体
	// 11111111 11111111
	// 首先是4byte的int32, 起始位置0, 结束位置+1 = 4, 0%4=4%4=0 可以放入;
	// 再是4byte的int32, 起始位置4, 结束位置+1 = 8, 4%8不足8 8%8=0 可以放入
	// 最后是 8byte 的int64, 起始位为8, 结束为16 放入后面8byte
	// 一共占用16字节  判断是否需要对齐 16 % max(4, 4, 8) = 0
}