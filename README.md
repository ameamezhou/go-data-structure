# go-data-structure

go 的数据结构

# string
首先要先了解机string类型在机器编码种的形式

    1、 1 bit 可以是 0/1  8 bit = 1 byte， 可以表示255个数，越多的bit可以表示越大的数字
    2、 stirng类型在机器中是怎么存储的？ --> “A” 在机器中通过编码会用 65 来表示， 01000001
    3、 那怎么表示 "AA" 呢？ 如果不用任何措施就无法知道怎么终止，比如说 0100 0001 0100 0001 要怎么和一个完整的字符区分呢？
    4、 首先最容易想到的一个方法就是使用定长编码，比如说利用编码种最高位来表示所有的字符，也就是说假设现在编码的规则是16个字节，那么所有的
        编码我们都要按照16字节来表示，所以 "AA" 就会表示成：
        0000 0000 0100 0001 0000 0000 0100 0001；
        也很容易发现这个方法会很明显造成内存资源的浪费
    5、 于是出现了变长编码，用0开头表示只占一个字节，110开头占2个字节，1110开头占3个字节，同时除了第一个字节中的标识位，占用多少字节就会
        在后面每个字节开头用10占位：
        比如 用 0100 0001 除去标识符0 剩下 1000001，转化为10进制为65，表示A;
        比如 用 1110 0100 1011 1000 1001 0110 除去 1110 的表示为，表示占用3个bit；再出去后面2个字节的10，剩下的 0100 1110 0001 0110
        转化为十进制是 19990 表示 ”世“
        
        ”界“ 的编码为 30028  二进制为 1110 1010 1001 100 一共15位，至少加上三字节对应的占位/表示为（4+2+2） 一共23位，刚好可以被装下
        为了填满字节所以在前面补0(在最前面补，不会影响值)，所以表示为
        [1110 0111] [10 010101] [10 001100]

>世：
1110 0100 1011 1000 1001 0110
> 
>[1110 0100] [10 111000] [10 010110]
> 
>1110
> 
>0100 1110 0001 0110
> 
>界：
>1110 1010 1001 100  至少加上三字节对应的占位/表示为（4+2+2） 一共23位
>
>[1110 1110] [10 101010] [100 01100]
> 
> 如果表示4个字节就是 11110 的标识符  这里标识符不一定只能四位, 最长能表示到 1111110


    二 现在就可以看字符串是什么结构了
    1 首先要有一段编码的起始地址
    2 知道了开头位置,还需要知道在哪里结尾
    3 C语言中使用\0来表示一个字符串的终止,但是这样会出现问题就是内容中不能出现\0
    4 Go 选择在起始地址后面存储了一个int类型的len字段用于表示string的长度

![img.png](string_struct.png)
```go
//字符串是字符串的运行时表示形式。
//它不能安全或便携使用，其表示可能
//在以后的版本中进行更改。
//
//与reflect.StringHeader不同，它的Data字段足以保证
//它引用的数据不会被垃圾收集。

type string struct {
    Data unsafe.Point
    Len  int
}

// 这一段代码在 internal\ursafeheader\unsafeheader.go 种被定义
// 那么A世界在Go种的存储方式就是
```


```go
// test code

package main

import (
	"fmt"
	"unsafe"
)

func main(){
	a := "hhdja"
	fmt.Println(unsafe.Sizeof(a))

	b := "sdfwesdfr"
	fmt.Println(unsafe.Sizeof(b))

	c := "asdflhkqwihefokasd"
	fmt.Println(unsafe.Sizeof(c))
}
```
![img.png](string_test.png)
这里我们可以看到这个 a,b,c 的 string 类型的长度都为 16 , 明明我们给它们初始化的长度并不是16

# slice
# array
# 内存对齐
# map
